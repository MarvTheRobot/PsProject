Properties {
    $Environment   = $BuildEnvironment    
    $projectProps  = Import-PowerShellDataFile -Path (
                        Join-Path $Environment.ProjectPath 'project.properties.psd1'
                    )
     
    $moduleName  = $projectProps.Name
    $projectRoot = $Environment.ProjectPath
    $sourceRoot  = $Environment.ModulePath
    $outputRoot  = $Environment.BuildOutput
    $outputPath  = Join-Path $outputRoot $moduleName

    $manifestSourcePath = $Environment.PSModuleManifest
    
    $testRoot       = Join-Path $projectRoot 'test'
    $libRoot        = Join-Path $projectRoot 'lib'
    $testResults    = Join-Path $projectRoot 'TestResults'

    if($projectProps.OutputVersioning -eq $true){
        $outputPath = Join-Path $outputRoot (Join-Path $moduleName $projectProps.Version)
    }

    $moduleFilePath = Join-Path $outputPath "$moduleName.psm1"

    $codeFolders    = "classes", "private", "public" #contents will be copied into PSM1 module file
    $copyFolders    = @() #folders within /src that need to be copied 'as-is' into module output
    $requirements   = Join-Path $projectRoot 'requirements.psd1'
}

FormatTaskName (("-" * 24) + ">[{0}]<" + ("-" * 24))

function Remove {
    [cmdletbinding()]
    param(
        [string]$Path,
        [string]$Description
    )
    "Removing $description"
    $item = Get-Item -Path $Path -ErrorAction SilentlyContinue
    if($null -ne $item){
        $item | Remove-Item -Recurse -Force -Confirm:$false | Out-Null
        if(-not(Test-Path $item.FullName)){
            "...$($item.BaseName) removed"
        }else{
            throw "UNABLE TO REMOVE $path"
        }
    }else{
        "...already clean. Nothing to do"
    }
}

Task Default -Depends Clean, Test, Analyze

Task BuildOnly {
    Set-BuildEnvironment -Path $projectRoot -Force
    #Create a new output folder, based on output path
    if (-not(Test-Path $outputPath)) {
        New-Item -ItemType Directory -Path $outputPath | Out-Null
    }

    #Write the content from each function file into the module file
    "# Generated by Psake 'Build' Task @ $(Get-Date)`n"   |
        Out-File -Path $moduleFilePath -Force -Encoding utf8
    "# -------------------------------------------------" | 
        Out-File -Path $moduleFilePath -Append -Encoding utf8

    [string[]]$publicFunctions = @() 
    
    #Loop through all source folders in $codeFolders,
    #  Copy content into single <module>.psm1 file
    #  If a public function, add into 'FunctionsToExport'
    foreach ($sourceFolder in $codeFolders) {
        Write-Verbose "Compiling $sourceFolder artefacts"
        if('public', 'private' -contains $sourceFolder){
            $sourceFolderLabel = "$sourceFolder functions"
        }else{
            $sourceFolderLabel = $sourceFolder
        }

        "`n#region $sourceFolderLabel`n" | 
            Out-File -Path $moduleFilePath -Append -Encoding utf8

        $lookInPath  = Join-Path -Path $sourceRoot -ChildPath $sourceFolder
        $scriptFiles = Get-ChildItem -Path $lookInPath -Include "*.ps1" -Exclude "*.tests.ps1" -Recurse
        
        Get-Content $scriptFiles | 
            Out-File -Path $moduleFilePath -Append -Encoding utf8

        if ($sourceFolder -eq 'public') { $publicFunctions += $scriptFiles.BaseName }

        "`n`n#endregion $sourceFolderLabel ------------------------------------------`n" | 
            Out-File -Path $moduleFilePath -Append -Encoding utf8
    }

    #If there are public functions ensure they are exported at the bottom of the .PSM1 file.
    if ($null -ne $publicFunctions -and $publicFunctions.Count -gt 0) {
        $quotedFunctions = $publicFunctions | foreach-object {
            Write-Output "'$_'"
        }    
        "Export-ModuleMember -Function @($($quotedFunctions -Join ', '))" | 
            Out-File -Path $moduleFilePath -Append -Encoding utf8
    }

    #Load project.properties and create a new module manifest
    #  this is because sometimes even a newly created manifest reports as invalid and I don't know why
    #    nor do I really care as this is possibly a neater way of working.
    #       although this does mean we need an empty <modulename>.psd1 file in src for BuildHelpers to find
    $moduleProperties = @{
        GUID          = $projectProps.GUID
        RootModule    = $projectProps.Name
        ModuleVersion = $projectProps.Version
        Description   = $projectProps.Description
        Author        = $projectProps.Author
        CompanyName   = $projectProps.CompanyName
        Copyright     = $projectProps.Copyright
        #Prerelease    = $projectProps.PreRelease
        FunctionsToExport = $publicFunctions
        Path          = Join-Path -Path $outputPath -ChildPath "$($moduleName).psd1"
    }
    New-ModuleManifest @moduleProperties -ErrorAction Stop
    (Get-ChildItem $outputPath).FullName
}

Task Build -Depends Clean, BuildOnly {}

Task Clean {
    Remove $outputPath "previous build of same module version"
}

Task CleanModules {
    Remove $libRoot "modules downloaded into the project folder"
}

Task CleanTestResults {
    Remove $testResults "previously executed test results"
}

Task CleanAll -Depends CleanModules, CleanTestResults {
    Remove $outputRoot "all previous builds of module"
}

task Test {
    if(-not(Test-Path -Path $testResults)){
        New-Item -Path $testResults -ItemType Directory
    }
    
    $resultsFilePath = Join-Path -Path $testResults -ChildPath "$moduleName-UNIT-RESULTS.xml"
    $results = Invoke-Pester -Path $sourceRoot -OutputFile $resultsFilePath -OutputFormat NUnitXml -PassThru
    
    if ($results.FailedCount -gt 0) {
        $results | Format-List
        Write-Error -Message 'One or more Pester tests failed. Build cannot continue!'
    }
}

task Analyze {
    if(-not(Test-Path -Path $testResults)){
        New-Item -Path $testResults -ItemType Directory
    }

    Get-ChildItem -Path $testRoot -File | foreach-object {
        $resultsFilePath = Join-Path -Path $testResults -ChildPath "$($_.BaseName)-STYLE-RESULTS.xml"
        $results = Invoke-Pester -Path $_.FullName -OutputFile $resultsFilePath -OutputFormat NUnitXml -PassThru
            
        if ($results.FailedCount -gt 0) {
            $results | Format-List
            Write-Error -Message 'One or more Pester tests failed. Build cannot continue!'
        }   
    }
}

Task BuildDocs {

}
